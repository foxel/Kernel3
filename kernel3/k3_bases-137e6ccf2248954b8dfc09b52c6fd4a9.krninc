<?php
if (!defined('F_STARTED')) die('Hacking attempt'); abstract class FBaseClass { protected $pool = Array(); protected function __get($name) { if (isset($this->pool[$name])) return $this->pool[$name]; return null; } protected function __set($name, $val) { return $val; } protected function poolLink($names) { print 'hello'; if (is_array($names)) foreach ($names as $name) $this->pool[$name] =& $this->$name; if (is_string($names) && !is_numeric($names)) $this->pool[$names] =& $this->$names; } } abstract class FEventDispatcher extends FBaseClass { private $events = Array(); private function __construct() {} public function addEventHandler($ev_name, $func_link) { $ev_name = strtolower($ev_name); if (!is_callable($func_link)) return false; $this->events[$ev_name][] = $func_link; return true; } protected function throwEvent($ev_name) { $ev_name = strtolower($ev_name); if (!isset($this->events[$ev_name])) return false; $args = (func_num_args() > 1) ? array_slice(func_get_args(), 1) : Array(); $ev_arr =& $this->events[$ev_name]; foreach ($ev_arr as $ev_link) call_user_func_array($ev_link, $args); return true; } protected function throwEventArr($ev_name, $args = Array()) { $ev_name = strtolower($ev_name); if (!isset($this->events[$ev_name])) return false; if (!is_array($args)) $args = Array(); $ev_arr =& $this->events[$ev_name]; foreach ($ev_arr as $ev_link) call_user_func_array($ev_link, $args); return true; } protected function throwEventRef($ev_name, &$var) { $ev_name = strtolower($ev_name); if (!isset($this->events[$ev_name])) return false; $args = Array(&$var); if (func_num_args() > 2) $args = array_merge($args, array_slice(func_get_args(), 2)); $ev_arr =& $this->events[$ev_name]; foreach ($ev_arr as $ev_link) call_user_func_array($ev_link, $args); return true; } } final class StaticInstance { private $c = null; public function __construct($c) { if (class_exists($c)) $this->c = $c; } public function __call($m, $data) { if ($this->c && method_exists($this->c, $m)) return call_user_func_array(Array($this->c, $m), $data); return null; } public function __get($p) { if ($this->c) return @constant($this->c.'::'.$p); return null; } } class FException extends Exception { } class FMisc { const DF_PLAIN = 0; const DF_SERIALIZED = 1; const DF_SLINE = 2; const DF_MLINE = 3; const DF_BLOCK = 4; private static $dfMasks = Array('', '', '#^\s*([\w\-\/]+)\s*=>(.*)$#m', '#^((?>\w+)):(.*?)\r?\n---#sm', '#<<\+ \'(?>(\w+))\'>>(.*?)<<- \'\\1\'>>#s'); private function __construct() {} static public function obFree() { $i = ob_get_level(); while ($i--) ob_end_clean(); return (ob_get_level() == 0); } static public function mkdirRecursive($path, $chmod = null) { if (is_dir($path)) return true; elseif (is_file($path)) return false; if (!is_int($chmod)) $chmod = 0755; $pdir = dirname($path); if (!is_dir($pdir)) self::mkdirRecursive($pdir, $chmod); return mkdir($path, $chmod); } static public function loadDatafile($path, $format = self::DF_PLAIN, $force_upcase = false, $explode_by = '') { $indata = (file_exists($filename)) ? file_get_contents($filename) : false; if ($indata == false) return false; switch ($format) { case DF_SERIALIZED: return unserialize($indata); case DF_SLINE: case DF_MLINE: case DF_BLOCK: $matches = Array(); $arr = Array(); preg_match_all(self::$dfMasks[$format], $indata, $matches); if (is_array($matches[1])) { $names =& $matches[1]; $vars =& $matches[2]; foreach ($names as $num => $name) { if ($force_upcase) $name = strtoupper($name); $var = trim($vars[$num]); if ($explode_by) $var = explode($explode_by, $var); $arr[$name] = $var; } } return $arr; default: return $indata; } return null; } static public function timeDST($time, $tz = 0, $style = '') { static $styles = Array( 'eur' => Array('+m' => 3, '+d' => 25, '+wd' => 0, '+h' => 2, '-m' => 10, '-d' => 25, '-wd' => 0, '-h' => 2), 'usa' => Array('+m' => 3, '+d' => 8, '+wd' => 0, '+h' => 2, '-m' => 11, '-d' => 1, '-wd' => 0, '-h' => 2), ); static $defstyle = 'eur'; $style = strtolower($style); if (isset($styles[$style])) $DST = $styles[$style]; else $DST = $styles[$defstyle]; if (!isset($DST['gmt'])) $time += (int) $tz*3600; if ($data = gmdate('n|j|w|G', $time)) { $data = explode('|', $data); $cm = $data[0]; if ($cm < $DST['+m'] || $cm > $DST['-m']) return false; elseif ($cm > $DST['+m'] && $cm < $DST['-m']) return true; else { if ($cm == $DST['+m']) { $dd = $DST['+d']; if (isset($DST['+wd'])) $dwd = $DST['+wd']; $dh = $DST['+h']; $bres = false; } else { $dd = $DST['-d']; if (isset($DST['-wd'])) $dwd = $DST['-wd']; $dh = $DST['-h']; $bres = true; } $cd = $data[1]; if ($cd < $dd) return $bres; elseif (!isset($dwd)) { if ($cd > $dd) return !$bres; else return ($data[3] >= $dh) ? !$bres : $bres; } else { $cvwd = $cd - $dd; if ($cvwd >= 7) return !$bres; $cwd = $data[2]; $dvwd = ($dwd - $cwd + $cvwd) % 7; if ($dvwd < 0) $dvwd += 7; if ($cvwd < $dvwd) return $bres; elseif ($cvwd > $dvwd) return !$bres; else return ($data[3] >= $dh) ? !$bres : $bres; } } } else return false; } } if (!defined('F_STARTED')) die('Hacking attempt'); class FTimer { private $qTime; private $sTime; private $timePoints = Array(); private $timeLog = Array(); public function __construct() { $this->qTime = time(); $this->timePoints[] = $this->sTime = $this->microTime(); } public function microTime() { return microtime(true); } public function setTimer($id) { $id = $id ? $id : count($this->timePoints); $this->timePoints[$id] = $this->microTime(); return $id; } public function getTimer($id, $reset = false) { if (!isset($this->timePoints[$id])) return false; $out = $this->microTime() - $this->timePoints[$id]; if ($reset) $this->timePoints[$id] = $this->microTime(); return $out; } public function timeSpent() { return ($this->microTime() - $this->sTime); } public function logEvent($event = 'unknown') { $this->timeLog[] = Array( 'time' => $this->timeSpent(), 'name' => $event ); } public function getLog() { return $this->timeLog; } public function qTime() { return $this->qTime; } } if (!defined('F_STARTED')) die('Hacking attempt'); class FCache { const LIFETIME = 86400; const TEMPPREF = 'TEMP.'; static private $chdata = Array(); static private $got_cache = Array(); static private $upd_cache = Array(); static private $cache_folder = ''; static public function initCacher() { self::$cache_folder = F_DATA_ROOT.'cache'; if (!is_dir(self::$cache_folder)) FMisc::mkdirRecursive(self::$cache_folder); register_shutdown_function(Array(__CLASS__, 'close')); } static public function get($name) { $name = strtolower($name); if (!in_array($name, self::$got_cache)) { self::$chdata[$name] = self::CFS_Load($name); self::$got_cache[] = $name; } return self::$chdata[$name]; } static public function set($name, $value) { $name = strtolower($name); self::$chdata[$name] = $value; self::$got_cache[] = $name; self::$upd_cache[] = $name; } static public function drop($name) { $name = strtolower($name); self::$chdata[$name] = null; if (substr($name, -1) == '.') { $keys = array_keys(self::$chdata); foreach ($keys as $key) if (strpos($key, $name) === 0) self::$chdata[$key] = null; } self::$upd_cache[] = $name; } static public function dropList($list) { $names = explode(' ', $list); if (count($names)) { $out = Array(); foreach ($names as $name) self::drop($name); return true; } else return false; } static public function close() { self::$upd_cache = array_unique(self::$upd_cache); foreach (self::$upd_cache as $name) { $query = false; if (is_null(self::$chdata[$name])) self::CFS_Drop($name); else self::CFS_Save($name, self::$chdata[$name]); } self::$upd_cache = Array(); return true; } static public function clear() { self::$chdata = Array(); self::$upd_cache = Array(); self::CFS_Clear(); return true; } static public function requestTempFile($name) { if (!$name) return false; $name = strtolower(self::TEMPPREF.$name); $name = preg_replace('#[^0-9a-zA-Z_\-\.]#', '_', $name); $name = str_replace('.', '/', $name).'.chd'; $filename = self::$cache_folder.'/'.$name; return (FMisc::mkdirRecursive(dirname($filename))) ? $filename : null; } static private function CFS_Clear($folder = false) { $folder = rtrim($folder, '/'); $folder = (strpos($folder, self::$cache_folder.'/') === 0) ? $folder : self::$cache_folder; $stack = Array(); if (is_dir($folder) && $dir = opendir($folder)) { do { while ($entry = readdir($dir)) if ($entry!='.' && $entry!='..') { $entry = $folder.'/'.$entry; if (is_file($entry)) { $einfo = pathinfo($entry); if (strtolower($einfo['extension'])=='chd') unlink($entry); } elseif (is_dir($entry)) { if ($ndir = opendir($entry)) { array_push($stack, Array($dir, $folder)); $dir = $ndir; $folder = $entry; } } } closedir($dir); rmdir($folder); } while (list($dir, $folder) = array_pop($stack)); } } static private function CFS_Load($name) { Global $QF; if (!$name) return false; $name = preg_replace('#[^0-9a-zA-Z_\-\.]#', '_', $name); $name = str_replace('.', '/', $name).'.chd'; $filename = self::$cache_folder.'/'.$name; if (!file_exists($filename)) return null; if (filemtime($filename) < ($QF->Timer->time - QF_KERNEL_CACHE_LIFETIME)) return null; if ($data = file_get_contents($filename)) { $data = unserialize($data); return $data; } else return null; } static private function CFS_Save($name, $data) { if (!$name) return false; $name = preg_replace('#[^0-9a-zA-Z_\-\.]#', '_', $name); $name = str_replace('.', '/', $name).'.chd'; $data = serialize($data); $filename = self::$cache_folder.'/'.$name; return FMisc::mkdirRecursive(dirname($filename)) && file_put_contents($filename, $data); } static private function CFS_Drop($name) { if (!$name) return false; $name = preg_replace('#[^0-9a-zA-Z_\-\.]#', '_', $name); $name = str_replace('.', '/', $name); if (substr($name, -1) != '/') $name.= '.chd'; $file = self::$cache_folder.'/'.$name; if (is_file($file)) return unlink($file); elseif (is_dir($file)) return self::CFS_Clear($file); else return true; } } FCache::initCacher(); if (!defined('F_STARTED')) die('Hacking attempt'); class FStr { const COMM = 0; const HEX = 1; const WORD = 2; const HTML = 3; const PATH = 4; const LINE = 8; const URL_MASK_R = '[\w\#$%&~/\.\-;:=,?@+\(\)\[\]\|]+'; const URL_MASK_F = '(?>[0-9A-z]+://[0-9A-z_\-\.]+\.[A-z]{2,4})(?:\/[\w\#$%&~/\.\-;:=,?@+\(\)\[\]\|]+)?'; const EMAIL_MASK = '[0-9A-z_\-\.]+@[0-9A-z_\-\.]+\.[A-z]{2,4}'; const LTT_CACHEPREFIX = 'USTR.LTT.'; const CHR_CACHEPREFIX = 'USTR.CHR.'; const INT_ENCODING = F_INTERNAL_ENCODING; private static $ltts = Array(); private static $chrs = Array(); private static $useMB = false; private function __construct() {} static public function initEncoders() { self::$useMB = extension_loaded('mbstring'); setlocale(LC_ALL, 'EN'); if (self::$useMB) { mb_substitute_character(63); mb_language('uni'); mb_internal_encoding(self::INT_ENCODING); } if (function_exists('iconv_set_encoding')) iconv_set_encoding('internal_encoding', self::INT_ENCODING); } static public function strToUpper($string, $encoding = self::INT_ENCODING) { if (function_exists('mb_strtoupper') && $out = mb_strtoupper($string, $encoding)) return $out; $table = self::_getLetterTable($encoding); return strtr($string, $table); } static public function strToLower($string, $encoding = self::INT_ENCODING) { if (function_exists('mb_strtolower') && $out = mb_strtolower($string, $encoding)) return $out; $table = self::_getLetterTable($encoding); return strtr($string, array_flip($table)); } static public function strLen($string, $encoding = self::INT_ENCODING) { if (self::$useMB && $out = mb_strlen($string, $encoding)) return $out; elseif (function_exists('iconv_strlen') && $out = iconv_strlen($string, $encoding)) return $out; $encoding = strtolower($encoding); if ($encoding == 'utf-8') { $string = preg_replace('#[\x80-\xBF]+#', '', $string); return strlen($string); } else return strlen($string); } static public function strRecode($string, $to_enc = self::INT_ENCODING, $from_enc = self::INT_ENCODING ) { $from_enc = strtolower($from_enc); $to_enc = strtolower($to_enc); if (!$to_enc || !$from_enc) return false; if ($to_enc == $from_enc) return $string; if (self::$useMB && $out = mb_convert_encoding($string, $to_enc, $from_enc)) return $out; elseif (extension_loaded('iconv') && $out = iconv($from_enc, $to_enc.'//IGNORE//TRANSLIT', $string)) return $out; if ($from_enc == 'utf-8') return self::_subFromUtf($string, $to_enc); elseif ($to_enc == 'utf-8') return self::_subToUtf($string, $from_enc); else { if (!($table1 = self::_getCharTable($from_enc)) || !($table2 = self::_getCharTable($to_enc))) return false; $table = Array(); foreach($table1 as $ut=>$cp) $table[ord($cp)] = $table2[$ut]; $unk = (isset($table2[0x3F])) ? $table2[0x3F] : ''; unset($table1, $table2); $out = ''; $in_len = strlen($string); for ($i=0; $i<$in_len; $i++) { $ch = ord($string[$i]); $out.= (isset($table[$ch])) ? $table[$ch] : $out.= '?'; } return $out; } } static public function strToMime($string, $recode_to = '', $Quoted_Printable = false) { if (!$recode_to) $recode_to = self::INT_ENCODING; if ($recode_to && $recoded = self::strRecode($string, $recode_to)) $string = $recoded; else $recode_to = self::INT_ENCODING; if ($Quoted_Printable) $out = '=?'.$recode_to.'?Q?'.strtr(rawurlencode($string), '%', '=').'?='; else $out = '=?'.$recode_to.'?B?'.base64_encode($string).'?='; return $out; } static public function subStr($string, $start, $length = false, $encoding = self::INT_ENCODING) { if ($length === false) $length = strlen($string); if (self::$useMB && $out = mb_substr($string, $start, $length, $encoding)) return $out; elseif (function_exists('iconv_substr') && $out = iconv_substr($string, $start, $length, $encoding)) return $out; $encoding = strtolower($encoding); if ($encoding != 'utf-8') return substr($string, $start, $length); if ($letters = self::_utfExplode($string)) { $strLen = count($letters); if ($strLen <= $start) return false; $letters = array_slice($letters, $start, $length); $out = implode('', $letters); return $out; } return ''; } static public function smartTrim($string, $length = 15, $encoding = self::INT_ENCODING) { $len = self::strLen($string, $encoding); if ($len > $length) { $string = self::subStr($string, 0, $length); $pos = strrpos($string, ' '); if ($pos > 0) $string = substr($string, 0, $pos); return $string.'...'; } else return $string; } static public function cast($val, $type = self::COMM) { $val = (string) $val; switch ($type & 7) { case self::HEX: $val = strtolower(preg_replace('#[^0-9a-fA-F]#', '', $val)); break; case self::HTML: $val = htmlspecialchars($val); break; case self::WORD: $val = preg_replace('#[^0-9a-zA-Z_\-]#', '', $val); break; case self::PATH: $val = preg_replace('#(\\\|/)+#', DIRECTORY_SEPARATOR, $val); $val = preg_replace('#[\x00-\x1F\*\?\;\|]|/$|^\.$|(?<!^[A-z])\:#', '', $val); $val = trim($val); break; } if ($type & self::LINE) $val = preg_replace('#[\r\n]#', '', $val); return $val; } static public function unslash($data) { if (is_scalar($data)) { if (!is_numeric($data) && !is_null($data)) $data = stripslashes($data); } elseif (is_array($data)) { foreach ($data AS $key=>$val) $data[$key] = self::unslash($val); } elseif (is_object($data)) { foreach ($data AS $key=>$val) $data->$key = self::unslash($val); } return $data; } static public function htmlschars($data, $q_mode = ENT_COMPAT) { if (is_scalar($data)) { if (!is_numeric($data) && !is_null($data)) $data = htmlspecialchars($data, $q_mode); } elseif (is_array($data)) { foreach ($data AS $key=>$val) $data[$key] = self::htmlschars($val, $q_mode); } elseif (is_object($data)) { foreach ($data AS $key=>$val) $data->$key = self::htmlschars($val, $q_mode); } return $data; } static private $JS_REPLACE = array( '\\' => '\\\\', '/' => '\\/', "\r" => '\\r', "\n" => '\\n', "\t" => '\\t', "\b" => '\\b', "\f" => '\\f', '"' => '\\"', ); static public function JSDefine($data) { $odata = 'null'; if (is_bool($data)) $odata = $data ? 'true' : 'false'; elseif (is_scalar($data)) { $odata = '"'.strtr($data, self::$JS_REPLACE).'"'; } elseif (is_array($data) || is_object($data)) { $odata = Array(); foreach ($data AS $key=>$val) $odata[] = $key.': '.self::JSDefine($val); $odata = '{ '.implode(', ', $odata).' }'; } return $odata; } static public function PHPDefine($data, $tabs = 0) { $tab = '    '; $tabs = intval($tabs); $pref = str_repeat($tab, $tabs+1); if (is_numeric($data)) $def = $data; elseif (is_bool($data)) $def = (($data) ? 'true' : 'false'); elseif (is_null($data)) $def = 'null'; elseif (is_array($data) || is_object($data)) { $def = "Array (\n"; $fields = Array(); $maxlen = 0; foreach( $data as $key => $val ) { $field = (is_numeric($key)) ? $key." => " : '\''.addslashes($key).'\' => '; $field.= self::PHPDefine($val, $tabs+1); $fields[]= $pref.$field; } $def.=implode(" ,\n", $fields)."\n".$pref.') '; } else $def = '\''.addslashes($data).'\''; return $def; } static public function smartAmpersands($string) { return preg_replace('#\&(?!([A-z]+|\#\d{1,5}|\#x[0-9a-fA-F]{2,4});)#', '&amp;', $string); } static private $SCHARS = null; static public function smart_htmlschars($string) { if (is_null(self::$SCHARS)) { self::$SCHARS = get_html_translation_table(HTML_SPECIALCHARS); unset(self::$SCHARS['&']); } return strtr(self::smartAmpersands($string), self::$SCHARS); } static public function isEmail($string) { return !!preg_match('#^'.self::EMAIL_MASK.'$#D', $string); } static public function isUrl($string) { if (preg_match('#^'.self::URL_MASK_F.'$#D', $string)) return 1; if (preg_match('#^'.self::URL_MASK_R.'$#D', $string)) return 2; return 0; } static public function path($path) { self::cast($path, self::PATH); } static public function basename($name) { return (preg_match('#[\x80-\xFF]#', $name)) ? preg_replace('#^.*[\\\/]#', '', $name) : basename($name); } static public function basenameExt($name) { return (preg_match('#[\x80-\xFF]#', $name)) ? preg_replace('#^.*\.#', '', $name) : pathinfo($name, PATHINFO_EXTENSION); } static public function urlencode($string, $spec_rw = false) { $string = rawurlencode($string); if ($spec_rw) $string = str_replace('%2F', '/', $string); return $string; } static public function urlAddParam($url, $pname, $pdata, $with_amps = false, $replace = false) { $sep = ($with_amps) ? '&amp;' : '&'; if (stristr($url, 'javascript')) return $url; if (strstr($url, $pname.'=')) { if ($replace) $url = self::urlDropParam($url, $pname); else return $url; } $insert = ( !strstr($url, '?') ) ? '?' : $sep; $insert.= $pname.'='.rawurlencode($pdata); $url = preg_replace('#(\#|$)#', $insert.'\\1', $url, 1); return $url; } static public function urlDropParam($url, $pname) { return preg_replace('#(\?|&amp;|&)'.preg_quote($pname, '#').'=[^&\#]*#', '', $url); } static public function urlDataPack($data) { $data = (string) $data; $hash = self::shortHash($data); return rawurlencode(base64_encode($hash.'|'.$data)); } static public function urlDataUnpack($data) { $data = (string) $data; $data = base64_decode(rawurldecode($data)); list($hash, $data) = explode('|', $data, 2); $rhash = self::shortHash($data); return ($hash == $rhash) ? $data : false; } static public function fullUrl($url, $with_amps = false, $force_host = '') { if ($url{0} == '#') return $url; $url_p = parse_url($url); $url_p['scheme'] = strtolower($url_p['scheme']); if ($url_p['scheme'] == 'mailto') return $url; $url = ''; if (isset($url_p['scheme'])) $url.= $url_p['scheme'].'://'; else $url.= (F('HTTP')->Secure) ? 'https://' : 'http://'; if (isset($url_p['host'])) { if (isset($url_p['username'])) { $url.= $url_p['username']; if (isset($url_p['password'])) $url.= $url_p['password']; $url.= '@'; } $url.= $url_p['host']; if (isset($url_p['port'])) $url.= ':'.$url_p['port']; if (isset($url_p['path'])) $url.= preg_replace('#(\/|\\\)+#', '/', $url_p['path']); } else { $url.= ($force_host) ? $force_host : F('HTTP')->SrvName; if (isset($url_p['path'])) { if ($url_p['path']{0} != '/') $url_p['path'] = '/'.F('HTTP')->RootDir.'/'.$url_p['path']; } else $url_p['path'] = '/'.F('HTTP')->RootDir.'/'.F_SITE_INDEX; $url_p['path'] = preg_replace('#(\/|\\\)+#', '/', $url_p['path']); $url.= $url_p['path']; } if (isset($url_p['query'])) $url.= '?'.$url_p['query']; if (isset($url_p['fragment'])) $url.= '#'.$url_p['fragment']; $url = ($with_amps) ? preg_replace('#\&(?![A-z]+;)#', '&amp;', $url) : str_replace('&amp;', '&', $url); return $url; } static public function shortUID($add_entr = '') { static $etropy = ''; $out = str_pad(dechex(crc32(uniqid($add_entr.$etropy))), 8, '0', STR_PAD_LEFT); $etropy = $out; return $out; } static public function shortHash($data) { return str_pad(dechex(crc32($data)), 8, '0', STR_PAD_LEFT); } static private function _subFromUtf($string, $to_enc) { if ($to_enc == 'utf-8') return $string; if (!($table = self::_getCharTable($to_enc))) return false; $unk = (isset($table[0x3F])) ? $table[0x3F] : ''; if ($letters = self::_utfExplode($string)) { $out = ''; reset($letters); while (list($i, $lett) = each($letters)) { $uni = ord($lett[0]); if ($uni < 0x80) $uni = $uni; elseif (($uni >> 5) == 0x06) $uni = (($uni & 0x1F) << 6) | (ord($lett[1]) & 0x3F); elseif (($uni >> 4) == 0x0E) $uni = (($uni & 0x0F) << 12) | ((ord($lett[1]) & 0x3F) << 6) | (ord($lett[2]) & 0x3F); elseif (($uni >> 3) == 0x1E) $uni = (($uni & 0x07) << 18) | ((ord($lett[1]) & 0x3F) << 12) | ((ord($lett[2]) & 0x3F) << 6) | (ord($lett[3]) & 0x3F); else { $out.= $unk; continue; } $out.= (isset($table[$uni])) ? $table[$uni] : $unk; } } return $out; } static private function _subToUtf($string, $from_enc) { if ($from_enc == 'utf-8') return $string; if (!($table0 = self::_getCharTable($from_enc))) return false; $table = Array(); foreach ($table0 as $ut=>$cp) $table[ord($cp)] = $ut; unset($table0); $out = ''; $in_len = strlen($string); for ($i=0; $i<$in_len; $i++) { $ch = ord($string[$i]); if (isset($table[$ch])) { $uni = $table[$ch]; if ($uni < 0x80) $out.= chr($uni); elseif ($UtfCharInDec < 0x800) $out.= chr(($uni >> 6) + 0xC0).chr(($uni & 0x3F) + 0x80); elseif ($UtfCharInDec < 0x10000) $out.= chr(($uni >> 12) + 0xE0).chr((($uni >> 6) & 0x3F) + 0x80).chr(($uni & 0x3F) + 0x80); elseif ($UtfCharInDec < 0x200000) $out.= chr(($uni >> 18) + 0xF0).chr((($uni >> 12) & 0x3F) + 0x80).chr((($uni >> 6)) & 0x3F + 0x80). chr(($uni & 0x3F) + 0x80); else $out.= '?'; } else $out.= '?'; } return $out; } static private function _getLetterTable($encoding = self::INT_ENCODING) { $encoding = strtolower($encoding); $is_utf = ($encoding == 'utf-8'); $cachename = self::LTT_CACHEPREFIX.$encoding; if (isset(self::$ltts[$encoding])) { return self::$ltts[$encoding]; } elseif ($data = FCache::get($cachename)) { return (self::$ltts[$encoding] = $data); } elseif ($data = file_get_contents(F_KERNEL_DIR.'/chars/'.$encoding.'.ltt')) { $table = Array(); preg_match_all('#0x([0-9a-fA-F]{1,6})\[0x([0-9a-fA-F]{1,6})\]#', $data, $matches, PREG_SET_ORDER); if ($is_utf) foreach ($matches as $part) $table[self::_hexToUtf($part[1])] = self::_hexToUtf($part[2]); else foreach ($matches as $part) $table[self::_hexToChr($part[1])] = self::_hexToChr($part[2]); FCache::set($cachename, $table); return (self::$ltts[$encoding] = $table); } else { trigger_error('UString: There is no letter table for '.$encoding, E_USER_NOTICE); return Array(); } } static private function _getCharTable($encoding = self::INT_ENCODING) { $encoding = strtolower($encoding); if ($encoding == 'utf-8') return false; $cachename = self::CHR_CACHEPREFIX.$encoding; if (isset(self::$chrs[$encoding])) { return self::$chrs[$encoding]; } elseif ($data = F('Cache')->Get($cachename)) { return (self::$chrs[$encoding] = $data); } elseif ($data = file_get_contents(F_KERNEL_DIR.'/chars/'.$encoding.'.chr')) { $table = Array(); preg_match_all('#0x([0-9a-fA-F]{1,6})\[0x([0-9a-fA-F]{1,6})\]#', $data, $matches, PREG_SET_ORDER); foreach ($matches as $part) { $table[hexdec($part[1])] = self::_hexToChr($part[2]); } F('Cache')->Set($cachename, $table); return (self::$chrs[$encoding] = $table); } else { trigger_error('UString: Can\'t load chartable for '.$encoding, E_USER_WARNING); return false; } } static private function _hexToChr($Hex) { $dec = (hexdec($Hex) & 255); return chr($dec); } static private function _hexToUtf($UtfCharInHex) { $OutputChar = ''; $UtfCharInDec = hexdec($UtfCharInHex); if ($UtfCharInDec & 0x1F0000) return pack('C*', ($UtfCharInDec >> 18) | 0xF0, ($UtfCharInDec >> 12) & 0x3F | 0x80, ($UtfCharInDec >> 6) & 0x3F | 0x80, $UtfCharInDec & 0x3F | 0x80); elseif ($UtfCharInDec & 0xF800) return pack('C*', ($UtfCharInDec >> 12) | 0xE0, ($UtfCharInDec >> 6) & 0x3F | 0x80, $UtfCharInDec & 0x3F | 0x80); elseif ($UtfCharInDec & 0x780) return pack('C*', ($UtfCharInDec >> 6) | 0xC0, $UtfCharInDec & 0x3F | 0x80); else return chr($UtfCharInDec & 0x7F); } static private function _utfExplode($string) { $letters = Array(); if (preg_match_all('#[\x00-\x7F]|[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}#', $string, $letters)) $letters = $letters[0]; else $letters = Array(); return $letters; } } FStr::initEncoders(); if (!defined('F_STARTED')) die('Hacking attempt'); class FHTTPInterface extends FEventDispatcher { const DEF_COOKIE_PREFIX = 'F3'; const FILE_ATTACHMENT = 1; const FILE_RFC1522 = 8; const FILE_TRICKY = 16; private static $self = null; private $buffer = ''; public $doHTML = true; public $doGZIP = true; public static function getInstance() { if (!self::$self) self::$self = new FHTTPInterface(); return self::$self; } private function __construct() { $this->pool = Array( 'IP' => '', 'IPInt' => 0, 'rootUrl' => '', 'rootDir' => '', 'rootFull' => '', 'srvName' => '', 'cDomain' => false, 'cPrefix' => self::DEF_COOKIE_PREFIX, 'secure' => false, ); $this->pool['IP'] = $_SERVER['REMOTE_ADDR']; $this->pool['IPInt'] = ip2long($this->pool['IP']); $this->pool['srvName'] = preg_replace('#^\/*|\/*$#', '\1', trim($_SERVER['SERVER_NAME'])); $this->pool['rootUrl'] = 'http://'.$this->pool['srvName'].'/'; $this->pool['rootDir'] = dirname($_SERVER['PHP_SELF']); $this->pool['rootDir'] = preg_replace('#\/|\\\+#', '/', $this->pool['rootDir']); if ( $this->pool['rootDir'] = preg_replace('#^\/*|\/*$#', '', $this->pool['rootDir']) ) $this->RootUrl.= $this->RootDir.'/'; $this->pool['rootFull'] = preg_replace(Array('#\/|\\\+#', '#\/*$#'), Array('/', ''), $_SERVER['DOCUMENT_ROOT']).$this->pool['rootDir']; if (isset($_SERVER['HTTPS']) && ($_SERVER['HTTPS'] == 'on')) $this->pool['secure'] = true; if (headers_sent($file, $line)) trigger_error('QuickFox Kernel 3 HTTP initialization error (Headers already sent)', E_USER_ERROR); if (!FMisc::obFree()) trigger_error('QuickFox Kernel 3 HTTP initialization error (Output buffering is started elsewhere)', E_USER_ERROR); header('X-Powered-By: QuickFox kernel 3 (PHP/'.PHP_VERSION.')'); ob_start(array( &$this, 'obOutFilter')); ini_set ('default_charset', ''); } public function setCPrefix($new_prefix) { if (!$new_prefix) $new_prefix = self::DEF_COOKIE_PREFIX; $this->pool['cPrefix'] = (string) $new_prefix; } public function write($text, $no_nl = false) { if (is_scalar($text)) $this->buffer.= (string) $text; if (!$no_nl) $this->buffer.= "\n"; } public function writeFromOB($append = false, $no_nl = false) { if ($append) $this->buffer.= ob_get_contents(); else $this->buffer = ob_get_contents(); if (!$no_nl) $this->buffer.= "\n"; } public function getOB() { return ob_get_contents(); } public function clear() { $this->buffer = ''; } public function sendFile($file, $filename = '', $filemime = '', $filemtime = false, $flags = 0) { if (headers_sent()) { trigger_error('QuickFox Kernel 3 HTTP error', E_USER_ERROR); return false; } if (file_exists($file)) { ignore_user_abort(false); if (!$filename) $filename = $file; if (!$filemime) $filemime = 'application/octet-stream'; $filename = FStr::basename($filename); $disposition = ($flags & self::FILE_ATTACHMENT) ? 'attachment' : 'inline'; $FileSize = filesize($file); $FileTime = (is_int($filemtime)) ? $filemtime : gmdate('D, d M Y H:i:s ', filemtime($file)).'GMT'; if (isset($_SERVER['HTTP_RANGE']) && preg_match('#bytes\=(\d+)\-(\d*?)#i', $_SERVER['HTTP_RANGE'], $ranges)) { $NeedRange = true; $SeekFile = intval($ranges[1]); } else { $NeedRange = false; $SeekFile = 0; } if ($stream = fopen($file, 'rb')) { FMisc::obFree(); $filename = preg_replace('#[\x00-\x1F]+#', '', $filename); if (preg_match('#[^\x20-\x7F]#', $filename)) { if ($flags & self::FILE_RFC1522) { $filename = F('Str')->Str_Mime($filename); } elseif ($flags & self::FILE_TRICKY) { if (preg_match('#^text/#i', $filemime)) $disposition = 'attachment'; $filemime.= '; charset="'.F::INTERNAL_ENCODING.'"'; } else $filename = F('LNG')->Translit($filename); } header('Last-Modified: '.$FileTime); header('Expires: '.date('r', F('Timer')->qTime() + 3600*24), true); header('Content-Transfer-Encoding: binary'); header('Content-Disposition: '.$disposition.'; filename="'.$filename.'"'); header('Content-Type: '.$filemime); header('Content-Length: '.($FileSize - $SeekFile)); header('Accept-Ranges: bytes'); header('X-QF-GenTime: '.F('Timer')->timeSpent()); if ($NeedRange) { header($_SERVER['SERVER_PROTOCOL'] . ' 206 Partial Content'); header('Content-Range: bytes '.$SeekFile.'-'.($FileSize-1).'/'.$FileSize); } fseek($stream, $SeekFile); fpassthru($stream); fclose($stream); exit(); } } } public function sendBuffer($recode_to = '', $c_type = '', $force_cache = 0, $send_filename = '') { if (headers_sent()) { trigger_error('QuickFox HTTP error', E_USER_ERROR); return false; } FMisc::obFree(); if ($this->doHTML) { $this->throwEventRef('HTML_parse', $this->buffer); $statstring = sprintf(F('LNG')->lang('FOOT_STATS_PAGETIME'), F('Timer')->timeSpent()).' '; $this->buffer = str_replace('<!--Page-Stats-->', $statstring, $this->buffer); $c_type = (preg_match('#[\w\-]+/[\w\-]+#', $c_type)) ? $c_type : 'text/html'; } else $c_type = (preg_match('#[\w\-]+/[\w\-]+#', $c_type)) ? $c_type : 'text/plain'; if ($encoding = $recode_to) { if ($buffer = FStr::strRecode($this->buffer, $encoding)) $this->buffer = $buffer; else $encoding = F::INTERNAL_ENCODING; header('Content-Type: '.$c_type.'; charset='.$encoding); $meta_conttype = '<meta http-equiv="Content-Type" content="'.$c_type.'; charset='.$encoding.'" />'; } else { header('Content-Type: '.$c_type.'; charset='.F::INTERNAL_ENCODING); $meta_conttype = '<meta http-equiv="Content-Type" content="'.$c_type.'; charset='.F::INTERNAL_ENCODING.'" />'; } if ($this->doHTML) $this->buffer = str_replace('<!--Meta-Content-Type-->', $meta_conttype, $this->buffer); if ($this->doGZIP) { if ($this->tryGZIPEncode($this->buffer)) header('Content-Encoding: gzip'); } if ($force_cache > 0) header('Expires: '.date('r', F('Timer')->qTime() + $force_cache), true); else header('Cache-Control: no-cache'); if ($send_filename) header('Content-Disposition: attachment; filename="'.$send_filename.'"'); header('Content-Length: '.strlen($this->buffer)); header('X-QF-Page-GenTime: '.F('Timer')->timeSpent()); print $this->buffer; exit(); } public function sendBinary($data = '', $c_type = '', $force_cache = 0, $send_filename = '') { Global $QF; if (headers_sent()) { trigger_error('QuickFox HTTP error', E_USER_ERROR); return false; } FMisc::obFree(); $c_type = (preg_match('#[\w\-]+/[\w\-]+#', $c_type)) ? $c_type : 'application/octet-stream'; header('Content-Type: '.$c_type); if (false && $this->doGZIP) { if ($this->tryGZIPEncode($this->buffer)) header('Content-Encoding: gzip'); } if ($force_cache > 0) header('Expires: '.date('r', F('Timer')->qTime() + $force_cache), true); else header('Cache-Control: no-cache'); $data = ($data) ? $data : $this->buffer; if ($send_filename) header('Content-Disposition: attachment; filename="'.$send_filename.'"'); header('Content-Length: '.strlen($data)); header('X-QF-Page-GenTime: '.F('Timer')->timeSpent()); print $data; exit(); } public function setCookiesDomain($domain) { if (!preg_match('#[\w\.]+\w\.\w{2,4}#', $domain)) return false; $my_domain = '.'.ltrim(strtolower($this->SrvName), '.'); $domain = '.'.ltrim(strtolower($domain), '.'); $len = strlen($domain); if (substr($my_domain, -$len) == $domain) { $this->pool['cDomain'] = $domain; return true; } return false; } public function setCookie($name, $value = false, $expire = false, $root = false, $no_domain = false, $no_prefix = false) { if (!$root) $root = ($this->pool['rootDir']) ? '/'.$this->pool['rootDir'].'/' : '/'; if (!$no_prefix) $name = $this->pool['cPrefix'].'_'.$name; return ($no_domain) ? setcookie($name, $value, $expire, $root) : setcookie($name, $value, $expire, $root, $this->pool['cDomain']); } public function redirect($url) { if (headers_sent()) { trigger_error('QuickFox HTTP error', E_USER_ERROR); return false; } if (strstr(urldecode($url), "\n") || strstr(urldecode($url), "\r")) trigger_error('Tried to redirect to potentially insecure url.', E_USER_ERROR); FMisc::obFree(); $url = FStr::fullUrl($url); $this->callEventRef('HTTP_URL_Parse', $url ); $hurl = strtr($url, Array('&' => '&amp;')); if (@preg_match('/Microsoft|WebSTAR|Xitami/', getenv('SERVER_SOFTWARE'))) { header('Refresh: 0; URL='.$url); echo '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><meta http-equiv="refresh" content="0; url='.$hurl.'"><title>Redirect</title></head><body><div align="center">If your browser does not support meta redirection please click <a href="'.$hurl.'">HERE</a> to be redirected</div></body></html>'; exit(); } header('Location: '.$url); exit(); } public function setStatus($stat_code) { static $codes = Array( 400 => 'Bad Request', 401 => 'Unauthorized', 402 => 'Payment Required', 403 => 'Forbidden', 404 => 'Not Found', 405 => 'Method Not Allowed', 406 => 'Not Acceptable', 407 => 'Proxy Authentication Required', 408 => 'Request Timeout', 409 => 'Conflict', 410 => 'Gone', 411 => 'Length Required', 412 => 'Precondition Failed', 415 => 'Unsupported Media Type', 416 => 'Requested Range Not Satisfiable', 417 => 'Expectation Failed', 500 => 'Internal Server Error', 501 => 'Not Implemented', 503 => 'Service Unavailable', ); if (isset($codes[$stat_code])) header (implode(' ', Array($_SERVER["SERVER_PROTOCOL"], $stat_code, $codes[$stat_code]))); } public function getClientSignature($level = 0) { static $sign_parts = Array('HTTP_USER_AGENT', 'HTTP_ACCEPT', 'HTTP_ACCEPT_CHARSET'); static $psign_parts = Array('HTTP_VIA', 'HTTP_X_FORWARDED_FOR', 'HTTP_X_REAL_IP'); $sign = Array(); foreach ($sign_parts as $key) if (isset($_SERVER[$key])) $sign[] = $_SERVER[$key]; if ($level > 0) { $ip = explode('.', $this->pool['IP']); $sign[] = $ip[0]; $sign[] = $ip[1]; if ($level > 1) { $sign[] = $ip[2]; foreach ($psign_parts as $key) if (isset($_SERVER[$key])) $sign[] = $_SERVER[$key]; } if ($level > 2) $sign[] = $ip[3]; } $sign = implode('|', $sign); $sign = md5($sign); return $sign; } private function tryGZIPEncode(&$text, $level = 9) { if (!extension_loaded('zlib')) return false; $compress = false; if ( strstr($_SERVER['HTTP_ACCEPT_ENCODING'], 'gzip') ) $compress = true; $level = abs(intval($level)) % 10; if ($compress) { $gzip_size = strlen($text); $gzip_crc = crc32($text); $text = gzcompress($text, $level); $text = substr($text, 0, strlen($text) - 4); $out = "\x1f\x8b\x08\x00\x00\x00\x00\x00"; $out.= $text; $out.= pack('V', $gzip_crc); $out.= pack('V', $gzip_size); $text = $out; } return $compress; } public function obOutFilter($text) { if (!$this->buffer) return false; else return ''; } function _Close() { if ( headers_sent($file, $line) ) if ($file) { if ($file != __FILE__) trigger_error('Script module "'.$file.'" violated QF HTTP otput rules at line '.$line, E_USER_ERROR); } } } if (!defined('F_STARTED')) die('Hacking attempt'); class FLNGData { const CACHEPREFIX = 'LANG.'; const DEFLANG = 'RU'; const COMMON = 'kernel'; private $DATA_DIR = ''; private static $self = null; private $lang = Array(); private $lang_name = 'RU'; private $LNG_loaded = Array(); private $time_tr = null; private $bsize_tr = null; public static function getInstance() { if (!self::$self) self::$self = new FLNGData(); return self::$self; } private function __construct() { $this->DATA_DIR = F_DATA_ROOT.'langs'.DIRECTORY_SEPARATOR; $this->pool = Array( 'language' => &$this->lang_name, 'name' => &$this->lang_name, ); function FLang($key, $params = false, $load = false) { return F('LNG')->lang($key, $params, $load); } } private function __get($name) { if (isset($this->pool[$name])) return $this->pool[$name]; elseif (isset($this->lang[$name])) return $this->lang[$name]; return null; } public function _Start() { $this->loadKernelDefs(); } public function select($lang) { $n_lang = preg_replace('#\W#', '_', $lang); if ($this->lang_name == $n_lang) return true; $this->lang_name = $n_lang; $this->time_tr = null; $this->lang = Array(); $this->loadKernelDefs(); if ($parts = $this->LNG_loaded) { $this->LNG_loaded = Array(); foreach ($parts as $part) $this->loadLanguage($part); } return true; } public function ask() { return $this->lang_name; } public function loadLanguage($part = '') { Global $QF; if (!$part) $part = self::COMMON; else { $part = preg_replace('#\W#', '_', $part); if ($part != self::COMMON && !in_array(self::COMMON, $this->LNG_loaded)) $this->loadLanguage(); } if (!in_array($part, $this->LNG_loaded)) { $cachename = self::CACHEPREFIX.$this->lang_name.'.'.$part; if ($Ldata = FCache::get($cachename)) { $this->lang = $Ldata + $this->lang; F('Timer')->logEvent($this->lang_name.'.'.$part.' language loaded (from global cache)'); } else { $file = $part.'.lng'; $vdir = $this->DATA_DIR.$this->lang_name; $ddir = $this->DATA_DIR.self::DEFLANG; $odir = (file_exists($vdir.'/'.$file)) ? $vdir : $ddir; $file = $odir.'0/'.$file; if (!file_exists($file)) { trigger_error('LANG: '.$this->lang_name.'.'.$part.' lang file does not exist', E_USER_NOTICE ); } elseif (($Ldata = FMisc::loadDatafile($file, FMisc::DF_MLINE, true)) !== false) { FCache::set($cachename, $Ldata); $this->lang = $Ldata + $this->lang; F('Timer')->logEvent($this->lang_name.'.'.$part.' language file loaded (from lang file)'); } else trigger_error('LANG: error loading '.$this->lang_name.'.'.$part.' lang file', E_USER_WARNING ); } $this->LNG_loaded[] = $part; } return true; } public function lang($key, $params = false, $load = false) { $key = strtoupper($key); if (!$key) return ''; if ($load && !in_array($load, $this->LNG_loaded)) $this->loadLanguage($load); if (isset($this->lang[$key])) { $out = $this->lang[$key]; if ($params) { $params = is_array($params) ? array_values($params) : Array($params); array_unshift($params, ''); $out = preg_replace('#\$\{\d+\}#e', 'isset(\$params[\\1]) ? \$params[\\1] : \'\'', $out); } return $out; } else return '['.$key.']'; } public function _Call($key, $params = false, $load = false) { return $this->lang($key, $params, $load); } public function langParse($data, $prefix = 'L_') { if (is_scalar($data)) { if (preg_match('#^'.preg_quote($prefix, '#').'\w+$#D', $data)) $data = $this->lang(substr($data, strlen($prefix))); } elseif (is_array($data)) { foreach ($data AS $key => $val) $data[$key] = $this->langParse($val, $prefix); } elseif (is_object($data)) { foreach ($data AS $key => $val) $data->$key = $this->langParse($val, $prefix); } return $data; } public function timeFormat($timestamp = false, $format = '', $tz = false, $force_no_rels = false) { static $now, $correct, $today, $yesterday, $time_f, $last_tz = null, $no_rels; if (!$now) { $now = F('Timer')->qTime(); $correct = 0; $time_f = 'H:i'; $no_rels = false; } if (!count($this->LNG_loaded)) $this->loadLanguage(); if (!is_array($this->time_tr)) { $keys = Array( 1 => Array('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'), 2 => Array('Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'), 3 => Array('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'), 4 => Array('Jan', 'Feb', 'Mar', 'Apr', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'), ); $lnames = Array( 1 => 'DATETIME_TR_DAYS', 2 => 'DATETIME_TR_DAYS_SHORT', 3 => 'DATETIME_TR_MONTHS', 4 => 'DATETIME_TR_MONTHS_SHORT', ); $translate = Array(); for ($i = 1; $i<=4; $i++) { $lname = $lnames[$i]; if (isset($this->lang[$lname])) { $part = explode('|', $this->lang[$lname]); $pkeys = $keys[$i]; if (count($part) == count($pkeys)) foreach ($pkeys as $id => $key) $translate[$key] = $part[$id]; } } $this->time_tr = $translate; } else $translate = $this->time_tr; if (!is_numeric($timestamp)) $timestamp = $now; if (!is_numeric($tz)) $tz = 0; else $tz = intval($tz); $tzc = (3600 * $tz + 60 * $correct); if ($last_tz !== $tz) { $today = $now + $tzc; if (FMisc::timeDST($now, $tz)) $today+= 3600; $today = floor($today/86400)*86400; $yesterday = $today - 86400; $last_tz = $tz; } if (!$format) $format = 'd M Y H:i'; $timetodraw = $timestamp + $tzc; if (FMisc::timeDST($timestamp, $tz)) $timetodraw+= 3600; if ($no_rels || $force_no_rels || $timestamp == $now) $out = gmdate($format, $timetodraw); elseif ($timestamp > $now) { if ($timestamp < $now + 60) $out = sprintf($this->lang['DATETIME_FUTURE_SECS'], ($timestamp - $now)); elseif ($timestamp < $now + 3600) $out = sprintf($this->lang['DATETIME_FUTURE_MINS'], round(($timestamp - $now)/60)); else $out = gmdate($format, $timetodraw); } elseif ($timestamp > ($now - 60)) $out = sprintf($this->lang['DATETIME_PAST_SECS'], ($now - $timestamp)); elseif ($timestamp > ($now - 3600)) $out = sprintf($this->lang['DATETIME_PAST_MINS'], round(($now - $timestamp)/60)); elseif ($timetodraw > $today) $out = sprintf($this->lang['DATETIME_TODAY'], gmdate($time_f, $timetodraw)); elseif ($timetodraw > $yesterday) $out = sprintf($this->lang['DATETIME_YESTERDAY'], gmdate($time_f, $timetodraw)); else $out = gmdate($format, $timetodraw); if (count($translate)) $out = strtr($out, $translate); return $out; } public function sizeFormat($size, $bits = false) { if (!count($this->LNG_loaded)) $this->loadLanguage(); $size = (int) $size; if (!is_array($this->bsize_tr)) { $bnames = Array(0 => 'BSIZE_FORM_BYTES', 1 => 'BSIZE_FORM_BITS'); $this->bsize_tr = Array(0 => Array(1 => 'B'), 1 => Array(1 => 'b')); foreach ($bnames as $class => $cl_lang) if (isset($this->lang[$cl_lang]) && $this->lang[$cl_lang]) { $parts = explode('|', $this->lang[$cl_lang]); $i = 1; $this->bsize_tr[$class] = Array(); foreach ($parts as $part) { if (!$i) break; $this->bsize_tr[$class][$i] = $part; $i *= 1024; } krsort($this->bsize_tr[$class]); } } $bnames = $this->bsize_tr[(int) $bits]; $out = $size; foreach ($bnames as $bsize => $name) { if ($bsize == 1) { $out = sprintf('%d %s', $size, $name); break; } elseif ($size >= $bsize) { $size = $size/$bsize; $out = sprintf('%01.2f %s', $size, $name); break; } } return $out; } public function translit($inp) { static $trans_arr = null; if (is_null($trans_arr)) { if (!isset($this->lang['__TRANSLIT_FROM']) || !isset($this->lang['__TRANSLIT_TO'])) { $trans_arr = false; return preg_replace('#[\x80-\xFF]+#', '_', $inp); } $from = explode('|', $this->lang['__TRANSLIT_FROM']); $to = explode('|', $this->lang['__TRANSLIT_TO']); foreach ($from as $id => $ent) if (isset($to[$id])) $trans_arr[$ent] = $to[$id]; } if ($trans_arr) $inp = strtr($inp, $trans_arr); return preg_replace('#[\x80-\xFF]+#', '_', $inp); } private function loadKernelDefs() { static $K_lang = null; if (!is_null($K_lang)) { $this->lang = $K_lang + $this->lang; return true; } $file = F::KERNEL_DIR.'krnl_def.lng'; $cachename = self::CACHEPREFIX.'krnl_defs'; if ($Ldata = FCache::get($cachename)) { $this->lang = $Ldata + $this->lang; $K_lang = $Ldata; } elseif ($Ldata = FMisc::loadDatafile($file, FMisc::DF_MLINE, true)) { FCache::set($cachename, $Ldata); $this->lang = $Ldata + $this->lang; $K_lang = $Ldata; } else trigger_error('LANG: error loading kernel lang file: '.$file, E_USER_ERROR); return true; } } if (!defined('F_STARTED')) die('Hacking attempt'); class FDataBase extends FEventDispatcher { const SQL_NOESCAPE = 1; const SQL_USEFUNCS = 2; const SQL_WHERE_OR = 4; const SQL_SELECTALL = 8; const SQL_NOPREFIX = 16; const SQL_LEFTJOIN = 32; private $dbDrivers = Array('mysql' => 'mysql'); private $dbDSNType = Array('mysql' => 'mysql'); private $dbType = null; private $tbPrefix = 'qf_'; private $c = null; private $qc = null; private $qResult = null; private $history = Array(); private $queriesTime = 0; private $queriesCount = 0; public function __construct($dbaseType = 'mysql') { $this->dbType = $dbaseType; require_once(F_KERNEL_DIR.'k3_dbqc_'.$this->dbDrivers[$dbaseType].'.php'); $this->pool['dbType'] =& $this->dbType; $this->pool['qResult'] =& $this->qResult; $this->pool['history'] =& $this->history; $this->pool['queriesTime'] =& $this->queriesTime; $this->pool['queriesCount'] =& $this->queriesCount; } public function connect($params, $username = '', $password = '', $tbPrefix = 'qf_', $options = Array()) { $conn_pars = Array(); if (!is_array($params)) return false; foreach ($params as $key => $value) $conn_pars[] = $key.'='.$value; $conn_pars = $this->dbDSNType[$this->dbType].':'.implode(';', $conn_pars); $this->c = new PDO($conn_pars, $username, $password, $options); $this->tbPrefix = (string) $tbPrefix; $qcDriver = 'FDBaseQC'.$this->dbDrivers[$this->dbType]; $this->qc = new $qcDriver($this->c); } public function doSelect ($table, $fields = Array(), $where = '', $other = '', $flags = 0) { $ret = Array(); $query = $this->qc->simpleSelect($table, $fields, $where, $other, $flags); if ($result = $this->query($query, true)) { $ret = $this->fetchResult($result); $result->closeCursor(); return $ret; } else return null; } public function doSelectAll ($table, $fields = Array(), $where = '', $other = '', $flags = 0) { return $this->doSelect ($table, $fields, $where, $other, $flags | self::SQL_SELECTALL); } public function query($query = '', $noprefixrepl = false) { if (!$this->c) throw new FException('DB is not connected'); if( empty($query) ) return false; $start_time = F('Timer')->MicroTime(); $this->qResult = null; if (!$noprefixrepl) $query = preg_replace('#(?<=\W|^)(`?)\{DBKEY\}(\w+)(\\1)(?=\s|$|\n|\r)#s', '`'.$this->tbPrefix.'$2`', $query); $this->qResult = $this->c->query($query); $err = $this->c->errorInfo(); if ($err[1]) { $this->qResult = null; throw new FException('SQL Error '.$err[0].' ('.$this->dbType.' '.$err[1].'): '.$err[2]); } $query_time = F('Timer')->MicroTime() - $start_time; $this->queriesCount++; $this->queriesTime += $query_time; $this->history[] = Array('query' => $query, 'time' => $query_time); return $this->qResult; } public function fetchResult (PDOStatement $result, $flags = 0) { $ret = Array(); if ($flags & self::SQL_SELECTALL) { if ($result->columnCount() == 1) $ret = $result->fetchAll(PDO::FETCH_COLUMN); else $ret = $result->fetchAll(PDO::FETCH_ASSOC); } elseif ($result->columnCount() == 1) $ret = $result->fetchColumn(0); else $ret = $result->fetch(PDO::FETCH_ASSOC); return $ret; } } 
?>